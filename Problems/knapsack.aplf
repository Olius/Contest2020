 knapsack←{

     ⍝ A dynamic programming solution is used to solve the knapsack problem.
     ⍝ Writing Val[m;n] the maximum value attainable with the n first items
     ⍝ without using more than m in credit, we have the following relation:
     ⍝
     ⍝ Val[m;n+1] = Val[m;n] ⌈ Val[m-c;n] + v
     ⍝
     ⍝ where v and c are respectively the value and cost of item n+1,
     ⍝ except if m<c in which case the right argument to ⌈ is 0.
     ⍝ This is simply because item n+1 can either appear in an optimal
     ⍝ solution or not, and the better of the two optimums following each
     ⍝ of the two choices gives an optimal solution considering n+1 items.
     ⍝ If m<c, then we have no choice and must discard item n+1.
     ⍝
     ⍝ To transfer this to APL, we notice that Val[;n+1] depends only on
     ⍝ Val[;n], which leads to a folding implementation. After the first
     ⍝ fold, ↑maxTotals is precisely Val as described above. (Note the
     ⍝ slightly convoluted implementation due to Dyalog's lack of reverse-
     ⍝ scan operator. J has this as '\.'... maybe a good future addition? :)
     ⍝
     ⍝ We could have kept track of which choices led to the optimal value
     ⍝ in (↑maxTotals)[Money;⍴Values], but this would have cluttered the
     ⍝ elegant folding code. In any case we can recover it by checking wether
     ⍝ the optimal value attainable with our allowance changes from one row to
     ⍝ the one above, subtracting from our allowance the cost of the corres-
     ⍝ ponding item if it does.
     ⍝
     ⍝ We are left with a list leftoverMoney of our allowance after having
     ⍝ dealt with each item in succession, and the places where our savings
     ⍝ take a dent are where we have selected an item.

     Money←⍺
     Values Costs←⍵

     maxTotals←⊃{
         value cost←⍺
         maxs←⊃⌽⍵
         ⍵,⊂maxs⌈(-1+Money)↑value+(-cost)↓maxs
     }/(Values,¨Costs),⊂,⊂(1+Money)⍴0

     leftoverMoney←⊃{
         ⎕IO←0
         cost used←⍺
         leftover←⊃⌽⍵
         ⍵,leftover-cost×used[leftover]
     }/Money,⍨↓(⌽Costs),⍥⍪2≠/maxTotals

     2≠/leftoverMoney

 }
